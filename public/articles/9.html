<h1 class="article-title">Go. –°—Ç–∞—Ç—å—è. –ü—Ä–æ–µ–∫—Ç gRPC API (–∏–≥—Ä–∞ "–ü–æ–¥–±—Ä–∞—Å—ã–≤–∞–Ω–∏–µ –∫—É–±–∏–∫–∞")</h1>
<div class="article-meta">
    <span>üóì 09 –∏—é–Ω—è 2025</span>
    <span>üè∑Ô∏è Go, gRPC</span>
</div>
<p><b>–û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:</b></p>
<p>–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π –∏–≥—Ä–æ–≤–æ–π —Å–µ—Ä–≤–∏—Å –Ω–∞ Go —Å gRPC API, –≥–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–∑—ã–≤–∞–µ—Ç –º–µ—Ç–æ–¥ –¥–ª—è –∏–≥—Ä—ã –≤ ¬´–ø–æ–¥–±—Ä–∞—Å—ã–≤–∞–Ω–∏–µ –∫—É–±–∏–∫–∞¬ª —á–µ—Ä–µ–∑ —Ä—É—á–∫—É /Play. –°–µ—Ä–≤–∏—Å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –¥–≤–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–æ—Ç 1 –¥–æ 6): –æ–¥–∏–Ω –¥–ª—è –∏–≥—Ä–æ–∫–∞, –≤—Ç–æ—Ä–æ–π ‚Äî –¥–ª—è —Å–µ—Ä–≤–µ—Ä–∞. –ü–æ–±–µ–¥–∏—Ç–µ–ª—å –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –ø–æ –Ω–∞–∏–±–æ–ª—å—à–µ–º—É —á–∏—Å–ª—É. –†–µ–∑—É–ª—å—Ç–∞—Ç –∏–≥—Ä—ã –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö (PostgreSQL). –î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –æ–¥–∏–Ω –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ (–≤–Ω–µ—à–Ω–∏—Ö –∏–ª–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö).</p>
<p>–í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, –º—ã —Ç–∞–∫ –∂–µ –æ–ø–∏—à–µ–º —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Å Provably Fair (–¥–æ–∫–∞–∑—É–µ–º–æ —á–µ—Å—Ç–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º) - –±–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ä—É—á–µ–∫ –Ω–µ –æ–±–æ–π—Ç–∏—Å—å (CreateSession, Play, VerifyRoll).</p>
<h3 class="section-title">–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞, –ª–æ–≥–≥–µ—Ä, –∫–æ–Ω—Ñ–∏–≥</h3>
<p><b>–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞</b></p>
<ul>
    <li><b>cmd/</b> - —Ç—É—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã, + –º–∏–≥—Ä–∞—Ç–æ—Ä –¥–ª—è –º–∏–≥—Ä–∞—Ü–∏–π</li>  
    <li><b>config/</b> - –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å —Ñ–∞–π–ª–∞–º–∏ –∫–æ–Ω—Ñ–∏–≥–∞ –ø—Ä–æ–µ–∫—Ç–∞</li>
    <li><b>gen/</b> - —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ protoc —Ñ–∞–π–ª—ã</li>
    <li><b>internal/</b> - –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ "–∫–∏—à–∫–∏" –ø—Ä–æ–µ–∫—Ç–∞</li>
    <li><b>internal/api</b> - —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–∞–º–æ–≥–æ –∞–ø–∏ –∏–≥—Ä—ã</li>
    <li><b>internal/app</b> - —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è gRPC —Å–µ—Ä–≤–µ—Ä–∞</li>
    <li><b>internal/config</b> - —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ –∫–æ–Ω—Ñ–∏–≥–∞</li>
    <li><b>internal/generators</b> - —Ç—É—Ç –Ω–∞—Ö–æ–¥—è—Ç—Å—è —Ä–æ–ª–ª–µ—Ä—ã, –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã —á–∏—Å–µ–ª –¥–ª—è –±—Ä–æ—Å–∫–æ–≤</li>
    <li><b>internal/models</b> - –º–æ–¥–µ–ª–∏ –æ–±—ä–µ–∫—Ç–æ–≤</li>
    <li><b>internal/storage</b> - —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑–Ω—ã—Ö –≤–∏–¥–æ–≤ —Ö—Ä–∞–Ω–∏–ª–∏—â</li>
    <li><b>internal/utils</b> - —Ä–∞–∑–Ω–æ–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–µ</li>
    <li><b>migrations/</b> - —Ñ–∞–π–ª—ã –º–∏–≥—Ä–∞—Ü–∏–π</li>
    <li><b>proto/</b> - –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å –ø—Ä–æ—Ç–æ —Ñ–∞–π–ª–∞–º–∏</li>
    <li><b>tests/</b> - —Ç–µ—Å—Ç—ã</li>
</ul>
<p>–ù–∞—á–Ω–µ–º —Å –≥–ª–∞–≤–Ω–æ–≥–æ –¥–ª—è gRPC - –ø—Ä–æ—Ç–æ —Ñ–∞–π–ª–∞ proto/dice_roll.proto, –æ–ø–∏—Å—ã–≤–∞—é—â–µ–≥–æ –Ω–∞—à–µ –∞–ø–∏:</p>
<pre><code class="lang-protobuf">syntax = "proto3";

package dice_roll;

option go_package = "proto.dice_roll";

service DiceRollGameAPI {
    rpc CreateSession (CreateSessionRequest) returns (CreateSessionResponse);
    rpc Play (PlayRequest) returns (PlayResponse);
    rpc VerifyRoll (VerifyRequest) returns (VerifyResponse);
}

message CreateSessionRequest {
    string client_seed = 1;
}

message CreateSessionResponse {
    string session_id = 1;
    string server_seed_hash = 2;
}

message PlayRequest {
    string session_id = 1;
}

message PlayResponse {
    string createdAt = 1;
    int32 serverRoll = 2;
    int32 playerRoll = 3;
    string winner = 4;
    string roller = 5;
    string server_seed = 6;    // –†–∞—Å–∫—Ä—ã—Ç—ã–π –ø–æ—Å–ª–µ –±—Ä–æ—Å–∫–∞
    string client_seed = 7;    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–π seed
    int32 nonce = 8;           // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π —Å—á–µ—Ç—á–∏–∫ –¥–ª—è –±—Ä–æ—Å–∫–∞
    string generator_used = 9; // –ò–º—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ (–Ω–∞–ø—Ä., "crypto_sha256")
}

message VerifyRequest {
    string server_seed = 1;
    string client_seed = 2;
    int32 nonce = 3;
    string generator_name = 4;
    int32 expected_roll = 5;
}

message VerifyResponse {
    bool is_valid = 1;
}</code></pre>
<p>–°—Ä–∞–∑—É –∂–µ –ø–µ—Ä–µ–π–¥–µ–º –∫ —Ç–æ—á–∫–µ –≤—Ö–æ–¥–∞ cmd/dice_roll/main.go (–ø—Ä–∏–≤–µ–¥–µ–Ω —Å—Ä–∞–∑—É –∏—Ç–æ–≥–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –Ω–µ–¥–æ—Å—Ç–∞—é—â–µ–µ –æ–ø–∏—à–µ—Ç—Å—è –ø–æ–∑–∂–µ):</p>
<pre><code class="lang-go">package main

import (
	"dice_roll/internal/app"
	"dice_roll/internal/config"
)

const (
	envLocal = "local"
	envDev   = "dev"
	envProd  = "prod"
)

func main() {
	cfg := config.MustLoad()    // –≥—Ä—É–∑–∏–º –∫–æ–Ω—Ñ–∏–≥
	log := setupLogger(cfg.Env) // –≥—Ä—É–∑–∏–º –ª–æ–≥–≥–µ—Ä

	// –¢—É—Ç –Ω–∞–¥–æ –ø–æ–º–µ–Ω—è—Ç—å —Å—Ç—Ä–æ–∫—É –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –µ—Å–ª–∏ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ –≤ –¥–æ–∫–µ—Ä–µ
	appication := app.New(log, cfg.PostgresConnStrForDocker, cfg.GRPC.Port)
	go func() {
		appication.MustRun()
	}()
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT)
	<-stop
	appication.Stop()
	log.Info("Gracefully stopped")
}

// –§—É–Ω–∫—Ü–∏—è –≤—ã–±–∏—Ä–∞–µ—Ç –ª–æ–≥–≥–µ—Ä –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–∫—Ä—É–∂–µ–Ω–∏—è
func setupLogger(env string) *slog.Logger {
	var log *slog.Logger
	switch env {
	case envLocal:
		log = slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelDebug}))
	case envDev:
		log = slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelDebug}))
	case envProd:
		log = slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelInfo}))
	}
	return log
}</code></pre>
<p>–í main() –≥—Ä—É–∑–∏—Ç—Å—è –∫–æ–Ω—Ñ–∏–≥, –≥—Ä—É–∑–∏—Ç—Å—è –ª–æ–≥–≥–µ—Ä, –∏ —Å–æ–∑–¥–∞–µ—Ç—Å—è app gRPC - –∏ –∫—Ä—É—Ç–∏—Ç—Å—è –≤ –≥–æ—Ä—É—Ç–∏–Ω–µ, –ø–æ–∫–∞ –Ω–µ –≤—ã–∑–æ–≤–µ–º –æ—Å—Ç–∞–Ω–æ–≤–∫—É. –ü—Ä–∏—Å—É—Ç–≤—É–µ—Ç –∏ –∫–æ–¥ –¥–ª—è —Ö–æ—Ä–æ—à–µ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã - —á—Ç–æ–±—ã –æ–Ω–∞ –ø–µ—Ä–µ–¥ –æ–∫–æ–Ω—á–∞–Ω–∏–µ–º —É—Å–ø–µ–ª–∞ –∑–∞–∫—Ä—ã—Ç—å –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è, –≤—Å–µ –¥–æ—Å—á–∏—Ç–∞—Ç—å –∏ —Ç.–ø.</p>
<p>–ö–æ–¥ –¥–ª—è –º–∏–≥—Ä–∞—Ç–æ—Ä–∞ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤ —Å–æ—Å–µ–¥–Ω–µ–π —Å—Ç–∞—Ç—å–µ –ø–æ SSO Auth.</p>
<p>–§–∞–π–ª config/local.yaml —Å –∫–æ–Ω—Ñ–∏–≥–æ–º –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫:</p>
<pre><code class="lang-yaml">env:                      "local"
postgresConnStr:          "postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable"
postgresConnStrForDocker: "postgresql://postgres:postgres@db:5432/postgres?sslmode=disable"
grpc:  
  port:                   50051  
  timeout:                10h
</code></pre>
<p>–ö–æ–¥ internal/config/config.go –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥–∞ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤ —Å–æ—Å–µ–¥–Ω–µ–π —Å—Ç–∞—Ç—å–µ –ø–æ SSO Auth.</p>
<h3 class="section-title">–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Storage, –º–∏–≥—Ä–∞—Ü–∏–∏ –ë–î</h3>
<p>–î–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–≥—Ä—ã –Ω–∞–¥–æ –∑–∞–≤–µ—Å—Ç–∏ —Ç–∞–±–ª–∏—Ü—É –≤ –ë–î —á–µ—Ä–µ–∑ –º–∏–≥—Ä–∞—Ü–∏—é. –í migrations/1_init.up.sql –æ–ø–∏—à–µ–º:</p>
<pre><code class="lang-sql">CREATE TABLE IF NOT EXISTS game_results (
    id         SERIAL PRIMARY KEY,
    created_at TEXT    NOT NULL,
    server     INTEGER NOT NULL,
    player     INTEGER NOT NULL,
    winner     TEXT    NOT NULL,
    roller     TEXT    NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_id ON game_results (id);</code></pre>
<p>–ó–∞–ø—É—Å—Ç–∏–≤ –º–∏–≥—Ä–∞—Ç–æ—Ä, —Å–æ–∑–¥–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É, –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –º–æ–∂–Ω–æ —Å –ø–æ–º–æ—â—å—é psql.</p>
<p>–û–ø–∏—à–µ–º —Ñ–∞–π–ª internal/storage/postgres/postgres.go, –≥–¥–µ –±—É–¥–µ—Ç –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ –ë–î –∏ –º–µ—Ç–æ–¥ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –Ω–∞—à–µ–π –∏–≥—Ä—ã:</p>
<pre><code class="lang-go">package postgres

import (
	_ "github.com/lib/pq"

	"dice_roll/internal/models"
)

type Storage struct {
	db *sql.DB
}

func New(storageConnStr string) (*Storage, error) {
	const op = "storage.postgres.New"

	db, err := sql.Open("postgres", storageConnStr)
	if err != nil {
		return nil, fmt.Errorf("%s: %w", op, err)
	}
	return &Storage{db: db}, nil
}

func (s *Storage) SaveGameResults(
	ctx context.Context,
	log *slog.Logger,
	results models.GameResult,
) (models.GameResult, error) {
	const op = "storage.postgres.SaveGame"
	log = log.With(slog.String("op", op))

	created_at := results.CreatedAt
	server := results.ServerRoll
	player := results.PlayerRoll
	winner := results.Winner
	roller := results.Roller

	insertq := `INSERT INTO game_results (created_at, server, player, winner, roller)
						VALUES (($1), ($2), ($3), ($4), ($5))`
	stmt, err := s.db.Prepare(insertq)
	if err != nil {
		return models.GameResult{}, fmt.Errorf("%s: %w", op, err)
	}

	_, err = stmt.ExecContext(ctx, created_at, server, player, winner, roller)
	if err != nil {
		return models.GameResult{}, fmt.Errorf("%s: %w", op, err)
	}

	log.Debug("–î–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω—ã –≤ –ë–î...")
	return models.GameResult{
		CreatedAt:  created_at,
		ServerRoll: server,
		PlayerRoll: player,
		Winner:     winner,
		Roller:     roller,
	}, nil
}</code></pre>
<p>–¢–∞–∫ –∂–µ –æ–ø–∏—à–µ–º –º–æ–¥–µ–ª—å –Ω–∞—à–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ internal/models/game.go:</p>
<pre><code class="lang-go">package models

type GameResult struct {
	CreatedAt  string
	ServerRoll int32
	PlayerRoll int32
	Winner     string
	Roller     string
}</code></pre>
<h3 class="section-title">–û–ø–∏—Å–∞–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ App</h3>
<p>–ó–∞–ø—É—Å–∫–∞—Ç—å gRPC –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±—É–¥–µ—Ç —á–µ—Ä–µ–∑ –æ—Ç–¥–µ–ª—å–Ω—É—é —Å—É—â–Ω–æ—Å—Ç—å, –Ω–∞–∑–æ–≤–µ–º –µ–µ –∞–ø–ø. –†–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å—Å—è –æ–Ω–æ –±—É–¥–µ—Ç –≤ internal/app/app.go:</p>
<pre><code class="lang-go">package app

import (
	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"dice_roll/internal/api"
	inMemStorage "dice_roll/internal/storage"
	"dice_roll/internal/storage/postgres"
)

type App struct {
	log        *slog.Logger
	gRPCServer *grpc.Server
	port       int
}

// InterceptorLogger adapts slog logger to interceptor logger.
func InterceptorLogger(l *slog.Logger) logging.Logger {
	return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) {
		l.Log(ctx, slog.Level(lvl), msg, fields...)
	})
}

// New creates new gRPC server app.
func New(log *slog.Logger, pGstoragePath string, port int) App {
	loggingOpts := []logging.Option{logging.WithLogOnEvents(logging.PayloadReceived, logging.PayloadSent)}
	recoveryOpts := []recovery.Option{
		recovery.WithRecoveryHandler(func(p interface{}) (err error) {
			log.Error("Recovered from panic", slog.Any("panic", p))
			return status.Errorf(codes.Internal, "internal error")
		}),
	}

	pgStorage, err := postgres.New(pGstoragePath)
	if err != nil {
		panic(err)
	}
	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –≤ –ø–∞–º—è—Ç–∏ –¥–ª—è —Å–µ—Å—Å–∏–π
	inMemSessionStorage := inMemStorage.NewInMemoryStorage()
	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º DiceRollService —Å –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–µ–π –º–µ—Ç–æ–¥–æ–≤
	drService := api.NewService(inMemSessionStorage, *pgStorage, log)
	// –°–µ—Ä–≤–µ—Ä —Å–æ–∑–¥–∞—ë—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º
	gRPCServer := grpc.NewServer(grpc.ChainUnaryInterceptor(
		recovery.UnaryServerInterceptor(recoveryOpts...),
		logging.UnaryServerInterceptor(InterceptorLogger(log), loggingOpts...),
	))
	// –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –Ω–∞—à —Å–µ—Ä–≤–∏—Å
	api.Register(gRPCServer, drService)

	// –í–µ—Ä–Ω—É—Ç—å –æ–±—ä–µ–∫—Ç App —Å–æ –≤—Å–µ–º–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º–∏ –ø–æ–ª—è–º–∏
	return App{
		log:        log,
		gRPCServer: gRPCServer,
		port:       port,
	}
}

// MustRun runs gRPC server and panics if any error occurs.
func (a *App) MustRun() {
	if err := a.Run(); err != nil {
		panic(err)
	}
}

// Run runs gRPC server.
func (a *App) Run() error {
	const op = "grpcapp.Run"

	// –°–æ–∑–¥–∞—ë–º listener, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Å–ª—É—à–∏—Ç—å TCP-—Å–æ–æ–±—â–µ–Ω–∏—è, –∞–¥—Ä–µ—Å–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞—à–µ–º—É gRPC-—Å–µ—Ä–≤–µ—Ä—É
	l, err := net.Listen("tcp", fmt.Sprintf(":%d", a.port))
	if err != nil {
		return fmt.Errorf("%s: %w", op, err)
	}
	a.log.Info("grpc server started", slog.String("addr", l.Addr().String()))
	// –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ gRPC-—Å–æ–æ–±—â–µ–Ω–∏–π
	if err := a.gRPCServer.Serve(l); err != nil {
		return fmt.Errorf("%s: %w", op, err)
	}
	return nil
}

// Stop stops gRPC server.
func (a *App) Stop() {
	const op = "grpcapp.Stop"

	a.log.With(slog.String("op", op)).Info("stopping gRPC server", slog.Int("port", a.port))
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –≤ gRPCServer –º–µ—Ö–∞–Ω–∏–∑–º graceful shutdown
	a.gRPCServer.GracefulStop()
}
</code></pre>
<p>–ù–∞ –¥–∞–Ω–Ω–æ–º —ç—Ç–∞–ø–µ –Ω–∞–º –Ω—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é inMem —Ö—Ä–∞–Ω–∏–ª–∏—Ü–∞ –≤ –ø–∞–º—è—Ç–∏ –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Å–∞–º–æ–≥–æ –∞–ø–∏ –∏–≥—Ä—ã (–≤ –∫–æ–¥–µ –≤—ã—à–µ –≤–∏–¥–Ω–æ —Å—Å—ã–ª–∫–∏ –Ω–∞ –Ω–∏—Ö –≤ –∏–º–ø–æ—Ä—Ç–µ, –∏–¥–µ –ø–æ–¥—Å–≤–µ—Ç–∏—Ç –∫—Ä–∞—Å–Ω—ã–º).</p>
<p>–ù–∞—á–Ω–µ–º —Å –∫–æ–¥–∞ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –≤ internal/storage/session.go (–∫–æ—Ç–æ—Ä—ã–π —Ç–∞–∫ –∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å–µ—Å—Å–∏–∏ –∏–≥—Ä—ã):</p>
<pre><code class="lang-go">package storage

var (
	ErrSessionNotFound = errors.New("session not found")
)

type GameSession struct {
	ID         string
	ServerSeed string
	ClientSeed string
	Nonce      int
	CreatedAt  time.Time
}

type SessionStorage interface {
	Save(ctx context.Context, session *GameSession) error
	Get(ctx context.Context, id string) (*GameSession, error)
	Update(ctx context.Context, session *GameSession) error
	Delete(ctx context.Context, id string) error
}

type InMemoryStorage struct {
	mu       sync.RWMutex
	sessions map[string]*GameSession
}

func NewInMemoryStorage() *InMemoryStorage {
	return &InMemoryStorage{
		sessions: make(map[string]*GameSession),
	}
}

func (s *InMemoryStorage) Save(ctx context.Context, session *GameSession) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.sessions[session.ID] = session
	return nil
}

func (s *InMemoryStorage) Get(ctx context.Context, id string) (*GameSession, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	session, exists := s.sessions[id]
	if !exists {
		return nil, ErrSessionNotFound
	}
	return session, nil
}

func (s *InMemoryStorage) Update(ctx context.Context, session *GameSession) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if _, exists := s.sessions[session.ID]; !exists {
		return ErrSessionNotFound
	}
	s.sessions[session.ID] = session
	return nil
}

func (s *InMemoryStorage) Delete(ctx context.Context, id string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.sessions, id)
	return nil
}
</code></pre>
<h3 class="section-title">–û–ø–∏—Å–∞–Ω–∏–µ –ê–ü–ò</h3>
<p>–ù–∞–ø–∏—à–µ–º —Ñ–∞–π–ª –Ω–∞—à–µ–≥–æ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞-–∞–ø–∏ internal/api/service.go:</p>
<pre><code class="lang-go">package api

import (
	drgen "dice_roll/gen/go"
	"dice_roll/internal/generators"
	"dice_roll/internal/models"
	"dice_roll/internal/storage"
	"dice_roll/internal/storage/postgres"
	"dice_roll/internal/utils"

	"github.com/google/uuid"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type DiceRollService struct {
	drgen.UnimplementedDiceRollGameAPIServer
	log            *slog.Logger
	storage        postgres.Storage
	sessionStorage storage.SessionStorage
	generators     map[string]generators.RollGenerator
}

type DiceRollGameAPI interface {
	CreateSession(context.Context, *drgen.CreateSessionRequest) (*drgen.CreateSessionResponse, error)
	Play(context.Context, *drgen.PlayRequest) (*drgen.PlayResponse, error)
	VerifyRoll(context.Context, *drgen.VerifyRequest) (*drgen.VerifyResponse, error)
}

func NewService(
    sessionStorage storage.SessionStorage,
    storage postgres.Storage,
    log *slog.Logger,
) *DiceRollService {
	return &DiceRollService{
		log:            log,
		storage:        storage,
		sessionStorage: sessionStorage,
		generators: map[string]generators.RollGenerator{
			"CryptoHMACGenerator":  &generators.CryptoHMACGenerator{},
			"MathRandGenerator":    &generators.MathRandGenerator{},
			"ExternalAPIGenerator": &generators.ExternalAPIGenerator{},
			"XorshiftGenerator":    &generators.XorshiftGenerator{},
		},
	}
}

// –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–∞ –≤ gRPC —Å–µ—Ä–≤–µ—Ä–µ
func Register(gRPCServer *grpc.Server, drserver drgen.DiceRollGameAPIServer) {
	drgen.RegisterDiceRollGameAPIServer(gRPCServer, drserver)
}

// –§—É–Ω–∫—Ü–∏—è –≤—ã–±–∏—Ä–∞–µ—Ç —Ä–∞–Ω–¥–æ–º–Ω–æ –¥–æ—Å—Ç—É–ø–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
func (s *DiceRollService) selectRandomGenerator() generators.RollGenerator {
	keys := make([]string, 0, len(s.generators))
	for k := range s.generators {
		keys = append(keys, k)
	}
	return s.generators[keys[rand.Intn(len(keys))]]
}

// –§—É–Ω–∫—Ü–∏—è —Å—á–∏—Ç–∞–µ—Ç —Ö—ç—à –ø–æ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–º —Å–∏–¥–∞–º
func (s *DiceRollService) computeRollSignature(serverSeed, clientSeed string, nonce int) []byte {
	data := fmt.Sprintf("%s:%s:%d", serverSeed, clientSeed, nonce)
	mac := hmac.New(sha256.New, []byte(serverSeed))
	mac.Write([]byte(data))
	return mac.Sum(nil)
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
func (s *DiceRollService) determineWinner(playerRoll, serverRoll int32) string {
	switch {
	case playerRoll > serverRoll:
		return "player"
	case serverRoll > playerRoll:
		return "server"
	default:
		return "draw"
	}
}

func (s *DiceRollService) CreateSession(
	ctx context.Context,
	req *drgen.CreateSessionRequest,
) (*drgen.CreateSessionResponse, error) {
	const op = "DiceRollService.CreateSession"
	log := s.log.With("op", op)
	log.Debug("–°–æ–∑–¥–∞—é —Å–µ—Å—Å–∏—é...")

	clientSeed := req.GetClientSeed()
	if clientSeed == "" {
		return nil, status.Error(codes.InvalidArgument, "–ù—É–∂–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä client_seed")
	}

	session := &storage.GameSession{
		ID:         uuid.NewString(),
		ServerSeed: utils.MustGenerateRandomHex(32),
		ClientSeed: clientSeed,
		CreatedAt:  time.Now(),
	}

	if err := s.sessionStorage.Save(ctx, session); err != nil {
		return nil, status.Error(codes.Internal, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–∑–¥–∞–Ω–∏–∏—è —Å–µ—Å—Å–∏–∏")
	}
	hash := sha256.Sum256([]byte(session.ServerSeed))

	return &drgen.CreateSessionResponse{
		SessionId:      session.ID,
		ServerSeedHash: hex.EncodeToString(hash[:]),
	}, nil
}

func (s *DiceRollService) Play(
    ctx context.Context,
    req *drgen.PlayRequest,
) (*drgen.PlayResponse, error) {
	const op = "DiceRollService.Play"
	log := s.log.With("op", op)
	log.Debug("–ù–∞—á–∏–Ω–∞—é –∏–≥—Ä—É...")

	session, err := s.sessionStorage.Get(ctx, req.GetSessionId())
	if err != nil {
		if errors.Is(err, storage.ErrSessionNotFound) {
			log.Error("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!", slog.Any("err", err), slog.Any("session", session))
			return nil, status.Error(codes.NotFound, "–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
		}
		log.Error("–í–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –ø–æ–ª—É—á–∏—Ç—å —Å–µ—Å—Å–∏—é!", slog.Any("err", err))
		return nil, status.Error(codes.Internal, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –ø–æ–ª—É—á–∏—Ç—å —Å–µ—Å—Å–∏—é")
	}

	// –û–±–Ω–æ–≤–ª—è–µ–º nonce
	session.Nonce++
	if err := s.sessionStorage.Update(ctx, session); err != nil {
		return nil, status.Error(codes.Internal, "failed to update session")
	}

	generator := s.selectRandomGenerator()
	log.Debug("–í—ã–±—Ä–∞–Ω –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä...", slog.Any("generator", generator.Name()))
	seed := s.computeRollSignature(session.ServerSeed, session.ClientSeed, session.Nonce)
	serverRoll := generator.Generate(append(seed, 0x01)) // –î–æ–±–∞–≤–ª—è–µ–º –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å
	playerRoll := generator.Generate(seed)
	winner := s.determineWinner(playerRoll, serverRoll)
	log.Debug(
		"–ò–≥—Ä–∞ —Å—ã–≥—Ä–∞–Ω–∞, —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã...",
		slog.Any("playerRoll", playerRoll),
		slog.Any("serverRoll", serverRoll),
		slog.Any("winner", winner),
	)

	_, err = s.storage.SaveGameResults(ctx, s.log, models.GameResult{
		CreatedAt:  time.Now().Format(time.RFC3339),
		ServerRoll: serverRoll,
		PlayerRoll: playerRoll,
		Winner:     winner,
		Roller:     generator.Name(),
	})
	if err != nil {
		s.log.Error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –ë–î: %v", slog.Any("err", err))
	}

	return &drgen.PlayResponse{
		CreatedAt:     time.Now().Format(time.RFC3339Nano),
		ServerRoll:    serverRoll,
		PlayerRoll:    playerRoll,
		Winner:        winner,
		Roller:        generator.Name(),
		ServerSeed:    session.ServerSeed,
		ClientSeed:    session.ClientSeed,
		Nonce:         int32(session.Nonce),
		GeneratorUsed: generator.Name(),
	}, nil
}

func (s *DiceRollService) VerifyRoll(
    ctx context.Context,
    req *drgen.VerifyRequest,
) (*drgen.VerifyResponse, error) {
	const op = "DiceRollService.VerifyRoll"
	log := s.log.With("op", op)
	log.Debug("–í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç...")

	generator, exists := s.generators[req.GetGeneratorName()]
	if !exists {
		return nil, status.Error(codes.InvalidArgument, "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä")
	}

	seed := s.computeRollSignature(
		req.GetServerSeed(),
		req.GetClientSeed(),
		int(req.GetNonce()),
	)
	expected := generator.Generate(seed)
	return &drgen.VerifyResponse{IsValid: expected == req.GetExpectedRoll()}, nil
}</code></pre>
<p>–ü—Ä–æ–ø–∏—à–µ–º –ø–∞—Ä—É –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –≤ internal/utils.go:</p>
<pre><code class="lang-go">package utils

// generateRandomHex –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω—É—é
// —Å–ª—É—á–∞–π–Ω—É—é —Å—Ç—Ä–æ–∫—É –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã –≤ –±–∞–π—Ç–∞—Ö
// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ HEX-—Ñ–æ—Ä–º–∞—Ç–µ (–¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏ = length * 2)
func generateRandomHex(length int) (string, error) {
	if length <= 0 {
		return "", fmt.Errorf("length must be positive")
	}

	bytes := make([]byte, length)
	if _, err := rand.Read(bytes); err != nil {
		return "", fmt.Errorf("failed to generate random bytes: %w", err)
	}

	return hex.EncodeToString(bytes), nil
}

// MustGenerateRandomHex - –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞ generateRandomHex, –Ω–æ –ø–∞–Ω–∏–∫—É–µ—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è—Ö –≥–¥–µ –æ—à–∏–±–∫–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã
func MustGenerateRandomHex(length int) string {
	s, err := generateRandomHex(length)
	if err != nil {
		panic(err)
	}
	return s
}</code></pre>
<p>–ò–Ω—Ñ–æ –ø–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ proto-—Ñ–∞–π–ª–∞ –∏—Å–∫–∞—Ç—å –≤ —Å—Ç–∞—Ç—å–µ —Ä—è–¥–æ–º. –ü–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏, –æ—Å—Ç–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–ø–∏—Å–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∏–¥–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ - –ø–æ—Å–ª–µ –º–æ–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å, —á—Ç–æ –∏–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ.</p>
<h3 class="section-title">–ù–∞–ø–∏—à–µ–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã</h3>
<p>–ù–µ –±—É–¥–µ–º –æ–ø–∏—Å—ã–≤–∞—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞, –±–∞–Ω–∞–ª—å–Ω–æ. –û–≥—Ä–∞–Ω–∏—á–∏–º—Å—è –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–º–∏ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è Provably Fair. –ò—Ç–∞–∫</p>
<p><b>internal/generators/interface.go</b></p>
<pre><code class="lang-go">package generators

type RollGenerator interface {
	Generate(seed []byte) int32 // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ 1-6
	Name() string               // –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
}</code></pre>
<p><b>internal/generators/crypto.go</b></p>
<pre><code class="lang-go">package generators

type CryptoHMACGenerator struct{}

func (g *CryptoHMACGenerator) Generate(seed []byte) int32 {
	mac := hmac.New(sha256.New, seed)
	mac.Write([]byte("dice_roll"))
	result := mac.Sum(nil)
	number := binary.BigEndian.Uint32(result[:4])
	return int32(number%6) + 1
}

func (g *CryptoHMACGenerator) Name() string {
	return "CryptoHMACGenerator"
}</code></pre>
<p><b>internal/generators/external.go</b></p>
<pre><code class="lang-go">package generators

type ExternalAPIGenerator struct{}

func (g *ExternalAPIGenerator) Generate(seed []byte) int32 {
	sum := 0
	for _, b := range seed {
		sum += int(b)
	}
	return int32(sum%6) + 1
}

func (g *ExternalAPIGenerator) Name() string {
	return "ExternalAPIGenerator"
}</code></pre>
<p><b>internal/generators/math.go</b></p>
<pre><code class="lang-go">package generators

type MathRandGenerator struct{}

func (g *MathRandGenerator) Generate(seed []byte) int32 {
	return rand.Int31n(6) + 1
}

func (g *MathRandGenerator) Name() string {
	return "MathRandGenerator"
}</code></pre>
<p><b>internal/generators/xorshift.go</b></p>
<pre><code class="lang-go">package generators

type XorshiftGenerator struct{}

func (g *XorshiftGenerator) Generate(seed []byte) int32 {
	state := binary.BigEndian.Uint64(seed)
	state ^= state << 13
	state ^= state >> 7
	state ^= state << 17
	return int32(state%6) + 1
}

func (g *XorshiftGenerator) Name() string {
	return "XorshiftGenerator"
}</code></pre>
<p>–¢–µ–ø–µ—Ä—å –æ–Ω–∏ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–∏ —Ä–∞–Ω–¥–æ–º–Ω–æ–º –≤—ã–±–æ—Ä–µ –≤ –∏–≥—Ä–µ. –õ–µ–≥–∫–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ —á–µ—Ä–µ–∑ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.</p>
<p>–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∫–∞—Ä–∫–∞—Å –≥–æ—Ç–æ–≤, –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –º–æ–∂–Ω–æ –∫–æ–º–∞–Ω–¥–æ–π:</p>
<pre><code class="lang-bash">go run ./cmd/dice_roll/main.go --config=./config/local.yaml</code></pre>
